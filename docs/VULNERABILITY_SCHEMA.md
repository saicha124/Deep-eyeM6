# Vulnerability Schema Documentation

## Overview

Deep Eye's enhanced vulnerability reporting system captures comprehensive details about each discovered vulnerability, including HTTP request/response data, payload source tracking, and detection metadata.

## Vulnerability Object Structure

Each vulnerability is a dictionary with the following structure:

```python
{
    # Core Fields (Required)
    'type': str,                # Vulnerability type (e.g., "SQL Injection")
    'severity': str,            # Severity level: "critical", "high", "medium", "low", "info"
    'url': str,                 # Vulnerable URL
    'description': str,         # Detailed vulnerability description
    'evidence': str,            # Evidence of the vulnerability
    'remediation': str,         # How to fix the vulnerability
    'timestamp': str,           # When the vulnerability was discovered (YYYY-MM-DD HH:MM:SS)
    
    # Optional Fields
    'parameter': str,           # Vulnerable parameter name
    'payload': str,             # Attack payload used
    'cwe': str,                 # CWE identifier (e.g., "CWE-89")
    'plugin': str,              # Plugin name (if from a custom plugin)
    
    # Enhanced Capture Fields (New in v1.3.0+)
    'payload_info': dict,       # Payload source tracking
    'interaction': dict,        # HTTP request/response details
    'detector': dict,           # Detection source information
    'remediation_details': dict # Enhanced remediation from RemediationGuide
}
```

## Enhanced Fields

### 1. payload_info (Payload Source Tracking)

Tracks where the attack payload originated:

```python
'payload_info': {
    'payload': str,             # The actual payload string
    'origin': {
        'file': str,            # Source file path
        'line': int             # Line number in source file
    },
    'parameter': str,           # Which parameter was attacked
    'context': str              # Attack context description
}
```

**Example**:
```python
'payload_info': {
    'payload': "' OR '1'='1",
    'origin': {
        'file': 'core/ai_payload_generator.py',
        'line': 92
    },
    'parameter': 'id',
    'context': 'SQL injection authentication bypass attempt'
}
```

### 2. interaction (HTTP Request/Response Capture)

Captures complete HTTP interaction details:

```python
'interaction': {
    'method': str,              # HTTP method (GET, POST, etc.)
    'url': str,                 # Full request URL
    'headers': dict,            # Request headers (sensitive data redacted)
    'request_body': str,        # Request body/payload (truncated if >5KB)
    'status_code': int,         # HTTP response status code
    'response_body': str,       # Response body (truncated if >5KB)
    'latency': float            # Request latency in seconds
}
```

**Security Features**:
- Sensitive headers automatically redacted: `Authorization`, `Cookie`, `X-API-Key`, `API-Key`
- Request/response bodies truncated at 5000 bytes to prevent memory issues
- Binary data replaced with `[Binary Data]` placeholder

**Example**:
```python
'interaction': {
    'method': 'POST',
    'url': 'https://example.com/product/stock',
    'headers': {
        'Content-Type': 'application/xml',
        'User-Agent': 'Deep-Eye/1.3.0',
        'Authorization': '[REDACTED]'
    },
    'request_body': '<?xml version="1.0"?>...',
    'status_code': 200,
    'response_body': 'root:x:0:0:root:/root:/bin/bash...',
    'latency': 0.342
}
```

### 3. detector (Detection Source Information)

Tracks where the vulnerability was detected in the code:

```python
'detector': {
    'module': str,              # Python module name
    'class': str,               # Class name (optional)
    'file': str,                # Source file path
    'function': str,            # Function name (optional)
    'lines': str                # Code line range (optional)
}
```

**Example**:
```python
'detector': {
    'module': 'core.vulnerability_scanner',
    'class': 'VulnerabilityScanner',
    'file': 'core/vulnerability_scanner.py',
    'function': '_check_xxe',
    'lines': '407-524'
}
```

### 4. remediation_details (Enhanced Remediation)

Added by `RemediationGuide.enhance_vulnerability()`:

```python
'remediation_details': {
    'priority': str,            # Priority level: "CRITICAL", "HIGH", "MEDIUM"
    'fix_time': str,            # Estimated fix time (e.g., "1-2 days")
    'steps': list,              # List of step-by-step remediation instructions
    'code_example': str,        # Secure code examples
    'exploit_example': str,     # Attack scenario examples
    'solution': str,            # Detailed solution explanation
    'references': list          # List of reference URLs/documents
}
```

## Creating Vulnerabilities

### Using create_vulnerability Helper

The recommended way to create vulnerability records is using the `create_vulnerability()` helper function:

```python
from core.vulnerability_helper import create_vulnerability

vuln = create_vulnerability(
    vuln_type='SQL Injection',
    severity='critical',
    url='https://example.com/products?id=1',
    parameter='id',
    description='SQL injection vulnerability allows...',
    evidence='SQL error pattern detected...',
    remediation='Use parameterized queries...',
    cwe='CWE-89: Improper Neutralization of Special Elements',
    payload="1' OR '1'='1",
    payload_info={
        'payload': "1' OR '1'='1",
        'origin': {'file': 'core/ai_payload_generator.py', 'line': 92},
        'parameter': 'id',
        'context': 'SQL injection error-based detection'
    },
    interaction={
        'method': 'GET',
        'url': test_url,
        'headers': {...},
        'request_body': None,
        'status_code': 500,
        'response_body': '...',
        'latency': 0.156
    },
    detector={
        'module': 'core.vulnerability_scanner',
        'class': 'VulnerabilityScanner',
        'file': 'core/vulnerability_scanner.py',
        'function': '_check_sql_injection',
        'lines': '197-280'
    }
)
```

### Capturing HTTP Interactions

Use `HTTPClient.capture_interaction()` to capture request/response details:

```python
from utils.http_client import HTTPClient

# Make request and capture start time
start_time = time.time()
response = http_client.get(test_url)

# Capture interaction details
interaction = http_client.capture_interaction(
    response,
    request_body=payload,  # Optional: for POST requests
    start_time=start_time   # Optional: for latency calculation
)
```

## Scanner Implementation Pattern

When implementing or updating vulnerability scanners, follow this pattern:

```python
def _check_vulnerability(self, url: str, payloads: List[str]) -> List[Dict]:
    """Check for vulnerability with enhanced capture."""
    vulnerabilities = []
    
    # Define payload origin for tracking
    payload_origin = {
        'file': 'core/ai_payload_generator.py',
        'line': 123  # Adjust to actual line
    }
    
    # Define detector information
    DETECTOR_INFO = {
        **DETECTOR,  # Global detector constant
        'function': '_check_vulnerability',
        'lines': '100-200'  # Adjust to actual lines
    }
    
    for payload in payloads:
        try:
            # Make request and measure time
            start_time = time.time()
            response = self.http_client.get(test_url)
            
            # Capture interaction
            interaction = self.http_client.capture_interaction(
                response,
                request_body=payload if method=='POST' else None,
                start_time=start_time
            )
            
            # Check for vulnerability
            if vulnerability_detected:
                # Create payload info
                payload_info = {
                    'payload': payload,
                    'origin': payload_origin,
                    'parameter': param_name,
                    'context': 'Description of what this test does'
                }
                
                # Create vulnerability with all details
                vuln = create_vulnerability(
                    vuln_type='Vulnerability Name',
                    severity='critical|high|medium|low',
                    url=url,
                    parameter=param_name,
                    description='Detailed description...',
                    evidence='Evidence found...',
                    remediation='How to fix...',
                    cwe='CWE-XXX: Description',
                    payload=payload,
                    payload_info=payload_info,
                    interaction=interaction,
                    detector=DETECTOR_INFO
                )
                vulnerabilities.append(vuln)
                logger.info(f"Vulnerability found at {url}")
        
        except Exception as e:
            logger.debug(f"Error testing: {e}")
    
    return vulnerabilities
```

## Report Generation

When generating reports, the `ReportGenerator` automatically:

1. Enhances vulnerabilities with `RemediationGuide.enhance_vulnerability()`
2. Passes all fields to the Jinja2 template
3. Applies autoescaping for XSS prevention
4. Generates interactive HTML vulnerability digest

## Security Considerations

1. **Sensitive Data Redaction**: The following headers are automatically redacted:
   - `Authorization`
   - `Cookie`
   - `X-API-Key`
   - `API-Key`

2. **Body Truncation**: Request and response bodies are truncated at 5000 bytes to prevent:
   - Memory exhaustion
   - Performance issues
   - Excessive report sizes

3. **XSS Prevention**: All template rendering uses Jinja2 autoescaping

4. **Binary Data Handling**: Binary data is replaced with `[Binary Data]` placeholder

## Integration with Existing Code

### For Custom Plugins

Custom plugins should use the same pattern:

```python
from core.vulnerability_helper import create_vulnerability

class MyCustomPlugin:
    def scan(self, url, context):
        vulnerabilities = []
        
        # Your custom scanning logic
        if vulnerability_found:
            vuln = create_vulnerability(
                vuln_type='My Custom Vulnerability',
                severity='high',
                url=url,
                description='...',
                evidence='...',
                remediation='...',
                # Include payload_info, interaction, detector as shown above
                plugin='my_custom_plugin'  # Identify plugin source
            )
            vulnerabilities.append(vuln)
        
        return vulnerabilities
```

### For External Integrations

When integrating with external tools or APIs, maintain the schema:

```json
{
  "type": "SQL Injection",
  "severity": "critical",
  "url": "https://example.com/page",
  "description": "...",
  "evidence": "...",
  "remediation": "...",
  "timestamp": "2025-11-05 09:23:02",
  "payload_info": {
    "payload": "...",
    "origin": {"file": "...", "line": 123},
    "parameter": "...",
    "context": "..."
  },
  "interaction": {
    "method": "GET",
    "url": "...",
    "headers": {...},
    "status_code": 200,
    "response_body": "...",
    "latency": 0.123
  },
  "detector": {
    "module": "...",
    "file": "...",
    "function": "..."
  }
}
```

## Backwards Compatibility

The enhanced fields are optional. Legacy scanners that don't include `payload_info`, `interaction`, or `detector` will still work correctly. The report generator handles missing fields gracefully.

## References

- `core/vulnerability_helper.py` - Vulnerability creation functions
- `utils/http_client.py` - HTTP interaction capture
- `core/report_generator.py` - Report generation with templates
- `templates/vulnerability_digest.html` - Interactive HTML template
- `core/remediation_guide.py` - Enhanced remediation details

## Changelog

**v1.3.0+** (November 2025):
- Added `payload_info` for payload source tracking
- Added `interaction` for HTTP request/response capture
- Added `detector` for detection source information
- Enhanced `RemediationGuide` with detailed fix steps and code examples
- Created interactive HTML vulnerability digest template
- Implemented security hardening (redaction, truncation, XSS prevention)
